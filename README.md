# Лабораторная работа №1
Тема: Динамическое программирование

---

1. Задача: Climbing Stairs



    fun climbStairs(n: Int): Int {
        if (n <= 2) return n
        var prev1 = 1
        var prev2 = 2
        
        for (i in 3..n) {
            val current = prev1 + prev2
            prev1 = prev2
            prev2 = current
        }
        
        return prev2
    }

Сложность: O(n) по времени, O(1) по памяти

Методология: решение основывается на числах Фибоначчи, где для каждой ступеньки количество способов определяется как сумма способов для двух предыдущих ступенек.  
Используется динамическое программирование.

---

2. Задача: Jump Game II

```
    fun jump(nums: IntArray): Int {
        val n = nums.size
        if (n <= 1) return 0
        var jumps = 0
        var currentEnd = 0
        var farthest = 0
        
        for (i in 0 until n - 1) {
            farthest = maxOf(farthest, i + nums[i])
            
            if (i == currentEnd) {
                jumps++
                currentEnd = farthest
                
                if (currentEnd >= n - 1) break
            }
        }
        
        return jumps
    }
```

Сложность: O(n) по времени, O(1) по памяти

Методология: используется жадный алгоритм с динамическим программированием, где отслеживается наибольшее расстояние, которое можно достичь в пределах текущего диапазона прыжка.

---

3. Задача: Pascal's Triangle II

```
    fun getRow(rowIndex: Int): List<Int> {
        val row = MutableList(rowIndex + 1) { 1 }

        for (i in 1 until rowIndex) {
            row[i] = (row[i - 1].toLong() * (rowIndex - i + 1) / i).toInt()
        }

        return row
    }
```

Сложность: O(n) по времени, O(1) по памяти

Методология: каждый элемент строки вычисляется по формуле:
row[i] = row[i] * (k - i + 1) / i, где k — это индекс строки.
Для оптимизации используется одна строка для хранения всех элементов строки, что позволяет значительно сократить потребление памяти.

---

4. Задача: Best Time to Buy and Sell Stock

```
    fun maxProfit(prices: IntArray): Int {
        var minBuy = Int.MAX_VALUE
        var maxProfit = 0
        for (price in prices) {
            if (price < minBuy) {
                minBuy = price
            } else {
                maxProfit = maxOf(maxProfit, price - minBuy)
            }
        }
        return maxProfit
    }
```

Сложность: O(n) по времени, O(1) по памяти

Методология: решение основано на отслеживании минимальной цены покупки и максимальной прибыли, получаемой при продаже по текущей цене.

---

5. Задача: Best Time to Buy and Sell Stock II

```
    fun maxProfit(prices: IntArray): Int {
         var profit = 0
        for (i in 1 until prices.size) {
            if (prices[i] > prices[i - 1]) {
                profit += prices[i] - prices[i - 1]
            }
        }
        return profit
    }
```

Сложность: O(n) по времени, O(1) по памяти

Методология: решение использует жадный алгоритм, при котором прибыль начисляется каждый раз, когда цена следующего дня выше текущей.

---

1. Что такое динамическое программирование

Динамическое программирование - это метод оптимизации, который используется, когда задача может быть разбита на подзадачи, и каждая подзадача решается только один раз с сохранением результата.

В динамическом программировании есть два подхода:

Нисходящий (Top-Down): Рекурсия с мемоизацией
Восходящий (Bottom-Up): Итеративное заполнение таблицы решений

---

2. Что такое Big O()

Big O() - это математическая нотация, используемая для описания асимптотического поведения функций. В программировании она применяется для анализа временной и пространственной сложности алгоритмов.

Основные виды сложности:

O(1) - постоянное время

O(log n) - логарифмическое время

O(n) - линейное время

O(n log n) - линейно-логарифмическое время

O(n²) - квадратичное время

O(2ⁿ) - экспоненциальное время

---

3. Что такое мемоизация в рекурсии

Мемоизация - это техника оптимизации, при которой результаты выполнения функции кэшируются и возвращаются при повторных вызовах с теми же аргументами. В рекурсии это позволяет избежать повторных вычислений одних и тех же подзадач.